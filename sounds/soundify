#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  soundify - convert mp3s to a javascript module

  Prints source mjs for an object whose keys are sound names
  and whose values are ArrayBuffers with the data for the
  corresponding mp3, for all mp3s found in the current
  directory and below.  Callers can get playable sounds from
  these using BaseAudioContext.decodeAudioData().

  The generated module exports that object under the name
  "soundBytes".

"""
# XXX ok the output here is way too big.
# making this work at all first, but, perhaps try:
#  - write this all as a webassembly module (though that
#    would still need to be embedded somehow!)
#  - put the actual binary data in strings, with char escaping
#    ^^ if we do this it can 
#  - if the above suck, then -don't- embed the music and
#    instead stream it from fbmstudios.net and accept that
#    you don't get any music if you're playing offline.
import math
import os
import subprocess
import sys
import warnings

from pathlib import Path

# returns a filehandle for the data in the named file,
# to be read in mp3 format.
# Raises an OSError if the file cannot be opened or if
# the data cannot be converted to mp3.
def open_as_mp3(filename):
    basename, ext = os.path.splitext(filename)
    match ext:
        case '.mp3':
            return open(filename, 'rb')
        case '.m4a':
            # -aq 9 sets the audio quality lower, but that barely reduces
            # the output size.
            #cmd = [ 'ffmpeg', '-i', filename, '-vn', '-f', 'mp3', '-aq', '9', '-' ]
            cmd = [ 'ffmpeg', '-i', filename, '-vn', '-f', 'mp3', '-' ]
            return subprocess.Popen(cmd).stdout
            # return os.popen(cmd, mode='rb') # , buffering=0)

    # XXX OSError isn't really appropriate here..
    raise OSError(f"Unsupported format '{ext}' for {filename}")

def main():
    soundfiles = [ ]
    for root, dirs, files in os.walk('.'):
        for name in files:
            if name.endswith(('.mp3', '.m4a')):
                fn = os.path.relpath(os.path.join(root, name))
                soundfiles.append(fn)

    bytes_per_line = 8

    def byte_line(byte_slice):
        return ', '.join(map(hex, byte_slice))

    indent = '\t'
    def p_i(level, *args):    # "print indented"
        print(indent*level, *args, sep='')

    def soundname(filename):
        return Path(filename).stem

    soundnames = { }
    print("export const soundBytes = {")
    for file in soundfiles:
        sn = soundname(file)
        if sn in soundnames:
            warn(f"sounds {file} and {soundnames[sn]} both have name {sn}")

        with open_as_mp3(file) as soundfile:
            p_i(1, f"'{sn}': new Uint8Array([  // {file}")
            mp3bytes = soundfile.read()
            lend = 0
            for lnum in range(0, math.floor(len(mp3bytes)/bytes_per_line)):
                lstart = lnum * bytes_per_line
                lend   = lstart + bytes_per_line
                p_i(2, byte_line(mp3bytes[lstart:lend]), ",")

            p_i(2, byte_line(mp3bytes[lend:len(mp3bytes)]))
            p_i(2, "]).buffer,")

    p_i(0, "};")

if __name__ == '__main__':
    main()



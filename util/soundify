#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
  soundify - convert mp3s to a javascript object

  Prints source for an object whose keys are sound names
  and whose values are ArrayBuffers with the data for the
  corresponding mp3, for all mp3s found in the current
  directory and below.  Callers can get playable sounds from
  these using BaseAudioContext.decodeAudioData().

  The generated module exports that object under the name
  "soundBytes".

"""
# XXX^^ that ain't right anymore
import math
import os
import sys
import warnings

from pathlib import Path

def main():
    soundfiles = [ ]
    for root, dirs, files in os.walk('.'):
        for name in files:
            if name.endswith('.mp3'):
                fn = os.path.relpath(os.path.join(root, name))
                soundfiles.append(fn)

    bytes_per_line = 8

    def byte_line(byte_slice):
        return ', '.join(map(hex, byte_slice))

    indent = '\t'
    def p_i(level, *args):    # "print indented"
        print(indent*level, *args, sep='')

    def soundname(filename):
        return Path(filename).stem

    soundnames = { }
    p_i(0, "const sounds = {")
    for file in soundfiles:
        sn = soundname(file)
        if sn in soundnames:
            warn(f"sounds {file} and {soundnames[sn]} both have name {sn}")

        with open(file, "rb") as mp3:
            p_i(1, f"'{sn}': new Uint8Array([  // {file}")
            mp3bytes = mp3.read()
            lend = 0
            for lnum in range(0, math.floor(len(mp3bytes)/bytes_per_line)):
                lstart = lnum * bytes_per_line
                lend   = lstart + bytes_per_line
                p_i(2, byte_line(mp3bytes[lstart:lend]), ",")

            p_i(2, byte_line(mp3bytes[lend:len(mp3bytes)]))
            p_i(2, "]).buffer,")

    p_i(0, "};")

if __name__ == '__main__':
    main()
